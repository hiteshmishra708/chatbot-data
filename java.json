[
    {
        "question": "What is Java?",
        "answer": "Java is an object-oriented, high-level, general-purpose programming language originally designed by James Gosling and further developed by the Oracle Corporation. It is one of the most popular programming languages in the world. To know more about what is Java, Click here and know all the details of Java, Features, and Component."
    },
    {
        "question": "Explain about Java Virtual Machine? ",
        "answer": "JVM is a program that interprets the intermediate Java byte code and generates the desired output. It is because of byte code and JVM that programs written in Java are highly portable. \n"
    },
    {
        "question": "What are the features of Java?",
        "answer": "Following are the various features of the Java programming language:\nHigh Performance– Using a JIT (Just-In-Time) compiler allows high performance in Java. The JIT compiler converts the Java bytecode into machine language code, which then gets executed by the JVM.\nMulti-threading– A thread is a flow of execution. The JVM creates a thread which is called the main thread. Java allows the creation of several threads using either extending the thread class or implementing the Runnable interface.\nOOPS Concepts– Java follows various OOPS concepts, namely abstraction, encapsulation, inheritance, object-oriented, and polymorphism\nPlatform Independency– Java makes use of the Java Virtual Machine or JVM, which allows a single Java program to operate on multiple platforms without any modifications.\nYou may want to check out Java features in detail here. "
    },
    {
        "question": "How does Java enable high performance?",
        "answer": "In the Just-in-Time compilation, the required code is executed at run time. Typically, it involves translating bytecode into machine code and then executing it directly. For enabling high performance, Java can make use of the Just-In-Time compilation. The JIT compiler is enabled by default in Java and gets activated as soon as a method is called. It then compiles the bytecode of the Java method into native machine code. After that, the JVM calls the compiled code directly instead of interpreting it. This grants a performance boost."
    },
    {
        "question": "Differentiate between JVM, JRE, and JDK",
        "answer": "Answer: \nParameters \tJVM\tJRE\tJDK\nFull-Form\tJava Virtual Machine\tJava Runtime Environment\tJava Development Kit\nPurpose\tIt provides a runtime environment to execute Java bytecode. \tIt is a set of software tools used for developing Java applications. \tIt is a software development environment used to develop Java applications. \nExistence \tIt is a runtime instance created when we run a Java class. \tIt exists physically.\tIt exists physically.\nImplementation\tIts implementation is known as JRE \tIt is the implementation of JVM \t\nIt is an implementation of any one of the below given Java Platforms released by Oracle Corporation:\nStandard Edition Java Platform\nEnterprise Edition Java Platform\nMicro Edition Java Platform"
    },
    {
        "question": "What is the JIT compiler?",
        "answer": "JIT compiler runs after the program is executed and compiles the code into a faster form, hosting CPU's native instructing set. JIT can access dynamic runtime information, whereas a standard compiler doesn't and can make better optimizations like inlining functions that are used frequently. "
    },
    {
        "question": "Which Java IDE to use, and why?",
        "answer": ""
    },
    {
        "question": "A Java IDE is a software that allows Java developers to easily write as well as debug Java programs. It is basically a collection of various programming tools, accessible via a single interface, and several helpful features, such as code completion and syntax highlighting. Codenvy, Eclipse, and NetBeans are some of the most popular Java IDEs.",
        "answer": ""
    },
    {
        "question": "Java is a platform-independent language. Why?",
        "answer": "Java programming language does not depend on any particular hardware or software because it is compiled by the compiler and then converted into byte code. Byte code is platform-independent and can run on multiple systems. The only requirement is Java needs a runtime environment, i.e., JRE, which is a set of tools used for developing Java applications."
    },
    {
        "question": "Explain Typecasting",
        "answer": "The concept of assigning a variable of one data type to a variable of another data type. It is not possible for the boolean data type.\n\nIt is of two types:\nImplicit\nExplicit"
    },
    {
        "question": "Explain different types of typecasting?",
        "answer": "Answer:\nDifferent types of typecasting are:\nImplicit: Storing values from a smaller data type to the larger data type. It is automatically done by the compiler.\n\nExplicit: Storing the value of a larger data type into a smaller data type. This results in information loss:\n\nTruncation: While converting a value from a larger data type to a smaller data type, the extra data would be truncated.\nLet us see the code example: \n   float f = 3.14f; \n   int i  = (int) f; \nAfter execution, i will contain only 3 and would truncate the rest when we go from float to integer. \nOut of Range: Typecasting does not allow to assign value more than its range; if that happens then the data is lost in such case. \nLet us understand this: \nlong l = 123456789; \nbyte b = (byte) l;      // byte is of not the same range as long so there will be loss of data. "
    },
    {
        "question": "Questions: Explain access modifiers in Java.",
        "answer": "Access modifiers are predefined keywords in Java that are used to restrict the access of a class, method, constructor, and data member in another class.\nJava supports four access modifiers:\nDefault\nPrivate\nProtected\nPublic\nModifier\tDefault\tPrivate\tProtected\tPublic\nSame class\tyes\tyes\tyes\tyes\nSame package subclass\tyes\tno\tyes\tyes\nSame package non-subclass\tyes\tno\tyes\tyes\nDifferent package subclass\tno\tno\tyes\tyes\nDifferent package non-subclass\tno\tno\tno\tyes"
    },
    {
        "question": "What are the default values for local variables?",
        "answer": "The local variables are not initialized to any default value, neither primitives nor object references.\n\nOOPS Java Interview Questions"
    },
    {
        "question": "What is Object-Oriented Programming? ",
        "answer": "OOPs is a programming paradigm centred around objects rather than functions. It is not a tool or a programming language it is a paradigm that was designed to overcome the flaws of procedural programming. There are many languages that follow OOPs concepts, some popular ones are Java, Python, Ruby and more. Some frameworks also follow OOPs concepts, Angular is one such framework."
    },
    {
        "question": "Could you explain the Oops concepts?",
        "answer": "Following are the various OOPS Concepts:\nAbstraction– Representing essential features without the need to give out background details. The technique is used for creating a new suitable data type for some specific application\nAggregation– All objects have their separate lifecycle, but ownership is present. No child object can belong to some other object except for the parent object\nAssociation– The relationship between two objects, where each object has its separate lifecycle. There is no ownership\nClass– A group of similar entities\nComposition– Also called the death relationship, it is a specialized form of aggregation. Child objects don't have a lifecycle. As such, they automatically get deleted if the associated parent object is deleted\nEncapsulation– Refers to the wrapping up of data and code into a single entity. Allows the variables of a class to be only accessible by the parent class and no other classes\nInheritance– When an object acquires the properties of some other object, it is called inheritance. It results in the formation of a parent-child relationship amongst classes involved. Offers a robust and natural mechanism of organizing and structuring software\nObject– Denotes an instance of a class. Any class can have multiple instances. An object contains the data as well as the method that will operate on the data\nPolymorphism– refers to the ability of a method, object, or variable to assume several forms\n \nDecision Making Java Interview Questions"
    },
    {
        "question": "Questions: Differentiate between break and continue",
        "answer": "Answer:\nBreak\tContinue\nUsed with both loop and switch statement\tUsed with only loop statements.\nIt terminates the loop or switch block.\tIt does not terminate but skips to the next iteration.\nClasses, Objects, and Methods Java Interview Questions"
    },
    {
        "question": "What is an Object?",
        "answer": "An instance of a Java class is known as an object. Two important properties of a Java object are behaviour and state. An object is created as soon as the JVM comes across the new keyword."
    },
    {
        "question": "Define classes in Java ",
        "answer": "A class is a collection of objects of similar data types. Classes are user-defined data types and behave like built-in types of a programming language. \nSyntax of a class: \nclass Sample{\nmember variables\nmethods() \n}\nExample of Class:\npublic class Shape\n   {\n      String Shape name;\n      void area()\n        {\n        }\n      void volume ()\n        {\n        }\n      void num_sides()\n        {\n        }\n   }"
    },
    {
        "question": "Explain what are static methods and variables?",
        "answer": "A class has two sections one declares variables, and other declares method, and these are called instance variables and instance methods, respectively. They are termed so because every time a class is instantiated, a new copy of each of them is created. \nVariables and methods can be created that are common to all objects and accessed without using a particular object by declaring them static. Static members are also available to be used by other classes and methods. "
    },
    {
        "question": "What do you mean by Constructor?",
        "answer": "A constructor is a method that has the same name as that of the class to which it belongs. As soon as a new object is created, a constructor corresponding to the class gets invoked. Although the user can explicitly create a constructor, it is created on its own as soon as a class is created. This is known as the default constructor. Constructors can be overloaded.\n\nNote: - If an explicitly-created constructor has a parameter, then it is necessary to create another constructor without a parameter."
    },
    {
        "question": "Please explain Local variables and Instance variables in Java.",
        "answer": "Variables that are only accessible to the method or code block in which they are declared are known as local variables. Instance variables, on the other hand, are accessible to all methods in a class. While local variables are declared inside a method or a code block, instance variables are declared inside a class but outside a method. Even when not assigned, instance variables have a value that can be null, 0, 0.0, or false. This isn't the case with local variables that need to be assigned a value, where failing to assign a value will yield an error. Local variables are automatically created when a method is called and destroyed as soon as the method exits. For creating instance variables, the new keyword must be used."
    },
    {
        "question": "Please explain Method Overriding in Java?",
        "answer": "Method Overriding in Java allows a subclass to offer a specific implementation of a method that has already been provided by its parent or superclass. Method overriding happens if the subclass method and the Superclass method have:\nThe same name\nThe same argument\nThe same return type"
    },
    {
        "question": "What do you mean by Overloading?",
        "answer": "Overloading is the phenomenon when two or more different methods (method overloading) or operators (operator overloading) have the same representation. For example, the + operator adds two integer values but concatenates two strings. Similarly, an overloaded function called Add can be used for two purposes\nTo add two integers\nTo concatenate two strings\nUnlike method overriding, method overloading requires two overloaded methods to have the same name but different arguments. The overloaded functions may or may not have different return types."
    },
    {
        "question": "What role does the final keyword play in Java? What impact does it have on a variable, method, and class?",
        "answer": "The final keyword in Java is a non-access modifier that applies only to a class, method, or variable. It serves a different purpose based on the context where it is used.\nWith a class\nWhen a class is declared as final, then it is disabled from being subclassed i.e., no class can extend the final class.\nWith a method\nAny method accompanying the final keyword is restricted from being overridden by the subclass.\nWith a variable\nA variable followed by the final keyword is not able to change the value that it holds during the program execution. So, it behaves like a constant.\nArrays, Strings and Vectors Java Interview Questions"
    },
    {
        "question": "Could you draw a comparison between Array and ArrayList?",
        "answer": "An array necessitates for giving the size during the time of declaration, while an array list doesn't necessarily require size as it changes size dynamically. To put an object into an array, there is the need to specify the index. However, no such requirement is in place for an array list. While an array list is parameterized, an array is not parameterized."
    },
    {
        "question": "Please explain the difference between String, String Builder, and String Buffer.",
        "answer": "String variables are stored in a constant string pool. With the change in the string reference, it becomes impossible to delete the old value. For example, if a string has stored a value \"Old,\" then adding the new value \"New\" will not delete the old value. It will still be there, however, in a dormant state. In a String Buffer, values are stored in a stack. With the change in the string reference, the new value replaces the older value. The String Buffer is synchronized (and therefore, thread-safe) and offers slower performance than the String Builder, which is also a String Buffer but is not synchronized. Hence, performance is fast in String Builder than the String Buffer.\n"
    },
    {
        "question": "Questions: What is String Pool in Java?",
        "answer": "The collection of strings stored in the heap memory refers to the String pool. Whenever a new object is created, it is checked if it is already present in the String pool or not. If it is already present, then the same reference is returned to the variable else new object is created in the String pool, and the respective reference is returned.\n \nAdvanced Java Interview Questions\nInterfaces and Abstract Classes Java Interview Questions"
    },
    {
        "question": "What do you know about Interface in Java?",
        "answer": "A Java interface is a template that has only method declarations and not method implementations. It is a workaround for achieving multiple inheritances in Java. Some worth remembering important points regarding Java interfaces are:\nA class that implements the interface must provide an implementation for all methods declared in the interface\nAll methods in an interface are internally public abstract void\nAll variables in an interface are internally public static final\nClasses do not extend but implement interfaces"
    },
    {
        "question": "How is an Abstract class different from an Interface?",
        "answer": "There are several differences between an Abstract class and an Interface in Java, summed up as follows:\nConstituents – An abstract class contains instance variables, whereas an interface can contain only constants.\nConstructor and Instantiation – While an interface has neither a constructor nor it can be instantiated, an abstract class can have a default constructor that is called whenever the concrete subclass is instantiated.\nImplementation of Methods – All classes that implement the interface need to provide an implementation for all the methods contained by it. A class that extends the abstract class, however, doesn't require implementing all the methods contained in it. Only abstract methods need to be implemented in the concrete subclass.\nType of Methods – Any abstract class has both abstract as well as non-abstract methods. Interface, on the other hand, has only a single abstract method."
    },
    {
        "question": "Please explain what do you mean by an Abstract class and an Abstract method?",
        "answer": "An abstract class in Java is a class that can't be instantiated. Such a class is typically used for providing a base for subclasses to extend as well as implementing the abstract methods and overriding or using the implemented methods defined in the abstract class. To create an abstract class, it needs to be followed by the abstract keyword. Any abstract class can have both abstract as well as non-abstract methods. A method in Java that only has the declaration and not implementation is known as an abstract method. Also, an abstract method name is followed by the abstract keyword. Any concrete subclass that extends the abstract class must provide an implementation for abstract methods."
    },
    {
        "question": "Questions: What is multiple inheritance? Does Java support multiple inheritance? If not, how can it be achieved?",
        "answer": "If a subclass or child class has two parent classes, that means it inherits the properties from two base classes, it is multiple inheritances. Java does not multiple inheritances as in case if the parent classes have the same method names, then at runtime, it becomes ambiguous, and the compiler is unable to decide which method to execute from the child class.\nPackages Java Interview Questions"
    },
    {
        "question": "What are the packages in Java? State some advantages of Packages in Java?",
        "answer": "Packages are Java's way of grouping a variety of classes and/or interfaces together. The functionality of the objects decides how they are grouped. Packagers act as \"containers\" to classes.\nEnlisted below are the advantages of Packages:\nClasses of other programs can be reused.\nTwo classes with the same can exist in two different packages.\nPackages can hide classes, thus denying access to certain programs and classes meant for internal use only.\nThey also separate design from coding.\nMultithreading Java Interview Questions"
    },
    {
        "question": "How do you make a thread in Java? Give examples.",
        "answer": "To make a thread in Java, there are two options:\nExtend the Thread Class – The thread is available in the java.lang.Thread class. To make a thread, you need to extend a thread class and override the run method. For example,\npublic class Addition extends Thread {\npublic void run() {\n}\n}\nA disadvantage of using the thread class is that it becomes impossible to extend any other classes.\nNonetheless, it is possible to overload the run() method in the class\n\nImplement Runnable Interface – Another way of making a thread in Java is by implementing a runnable interface. For doing so, there is the need to provide the implementation for the run() method that is defined in the\ninterface. For example,\npublic class Addition implements Runnable {\npublic void run() {\n}\n}"
    },
    {
        "question": "Why do we use the yield() method?",
        "answer": "The yield() method belongs to the thread class. It transfers the currently running thread to a runnable state and also allows the other threads to execute. In other words, it gives equal priority threads a chance to run. Because yield() is a static method, it does not release any lock."
    },
    {
        "question": "Can you explain the thread lifecycle in Java?",
        "answer": "The thread lifecycle has the following states and follows the following order:\nNew – In the very first state of the thread lifecycle, the thread instance is created, and the start() method is yet to be invoked. The thread is considered alive now.\nRunnable – After invoking the start() method, but before invoking the run() method, a thread is in the runnable state. A thread can also return to the runnable state from waiting or sleeping state.\nRunning – The thread enters the running state after the run() method is invoked. This is when the thread begins execution.\nNon-Runnable – Although the thread is alive, it is not able to run. Typically, it returns to the runnable state after some time.\nTerminated – The thread enters the terminated state once the run() method completes its execution. It is not alive now.\n"
    },
    {
        "question": "When is the Runnable interface preferred over thread class and vice-versa?",
        "answer": "In Java, it is possible to extend only one class. Hence, the thread class is only extended when no other class needs to be extended. If it is required for a class to extend some other class than the thread class, then we need to use the Runnable interface."
    },
    {
        "question": "Please draw a comparison between notify() and notifyAll() methods.",
        "answer": "The notify() method is used for sending a signal to wake up a single thread in the waiting pool. Contrarily, the notifyAll() method is used for sending a signal to wake up all threads in a waiting pool."
    },
    {
        "question": "How will you distinguish processes from threads?",
        "answer": "There are several fundamental differences between a process and a thread, stated as follows:\nDefinition – A process is an executing instance of a program whereas, a thread is a subset of a process.\nChanges – A change made to the parent process doesn't affect child processes. However, a change in the main thread can yield changes in the behavior of other threads of the same process.\nCommunication – While processes require inter-process communication for communicating with sibling processes, threads can directly communicate with other threads belonging to the same process.\nControl – Processes are controlled by the operating system and can control only child processes. On the contrary, threads are controlled by the programmer and are capable of exercising control over threads of the same process to which they belong.\nDependence – Processes are independent entities while threads are dependent entities\nMemory – Threads run in shared memory spaces, but processes run in separate memory spaces."
    },
    {
        "question": "What is the join() method? Give an example.",
        "answer": "We use the join() method for joining one thread with the end of the currently running thread. It is a non-static method and has an overloaded version. Consider the example below:\npublic static void main (String[] args) {\nThread t = new Thread();\nt.start();\nt.join();\n}\nThe main thread starts execution in the example mentioned above. As soon as the execution reaches the code t.start(), then the thread t starts its stack for execution. The JVM switches between the main thread and the thread there. Once the execution reaches the t.join(), then the thread t alone is executed and allowed to complete its task. Afterward, the main thread resumes execution."
    },
    {
        "question": "How do you make a thread stop in Java?",
        "answer": "There are three methods in Java to stop the execution of a thread:\nBlocking – This method is used to put the thread in a blocked state. The execution resumes as soon as the condition of the blocking is met. For instance, the ServerSocket.accept() is a blocking method that listens for incoming socket connection and resumes the blocked thread only when a connection is made.\nSleeping – This method is used for delaying the execution of the thread for some time. A thread upon which the sleep() method is used is said to enter the sleep state. It enters the runnable state as soon as it wakes up i.e., the sleep state is finished. The time for which the thread needs to enter the sleep state is mentioned inside the braces of the sleep() method. It is a static method.\nWaiting – Although it can be called on any Java object, the wait() method can only be called from a synchronized block.\nException Handling Java Interview Questions"
    },
    {
        "question": "Could you explain various types of Exceptions in Java? Also, tell us about the different ways of handling them.",
        "answer": "Java has provision for two types of exceptions:\nChecked Exceptions – Classes that extend Throwable class, except Runtime exception and Error, are called checked exceptions. Such exceptions are checked by the compiler during the compile time. These types of exceptions must either have appropriate try/catch blocks or be declared using the throws keyword. ClassNotFoundException is a checked exception.\nUnchecked Exceptions – Such exceptions aren't checked by the compiler during the compile time. As such, the compiler doesn't necessitate handling unchecked exceptions. Arithmetic Exception and ArrayIndexOutOfBounds Exception are unchecked exceptions.\nExceptions in Java are handled in two ways:\nDeclaring the throws keyword – We can declare the exception using throws keyword at the end of the method. For example:\nclass ExceptionCheck{\npublic static void main(String[] args){\nadd();\n}\npublic void add() throws Exception{\naddition();\n}\n}\nUsing try/catch – Any code segment that is expected to yield an exception is surrounded by the try block. Upon the occurrence of the exception, it is caught by the catch block that follows the try block. For example,\nclass ExceptionCheck{\npublic static void main (String[] args) {\nadd();\n}\npublic void add(){\ntry{\naddition();\n}\ncatch(Exception e)\n{\ne.printStacktrace();\n}\n}\n}"
    },
    {
        "question": "Could you draw the Java Exception Hierarchy?",
        "answer": "Answer:  \n"
    },
    {
        "question": "Is it possible to write multiple catch blocks under a single try block?",
        "answer": "Yes, it is possible to write several catch blocks under a single try block. However, the approach needs to be from specific to general. Following example demonstrates the same:\npublic class Example {\npublic static void main(String args[]) {\ntry {\nint a[]= new int[10];\na[10]= 10/0;\n}\ncatch(ArithmeticException e)\n{\nSystem.out.println(\"Arithmetic exception in first catch block\");\n}\ncatch(ArrayIndexOutOfBoundsException e)\n{\nSystem.out.println(\"Array index out of bounds in second catch block\");\n}\ncatch(Exception e)\n{\nSystem.out.println(\"Any exception in third catch block\");\n}\n}"
    },
    {
        "question": "How does the throw keyword differ from the throws keyword?",
        "answer": "While the throws keyword allows declaring an exception, the throw keyword is used to explicitly throw an exception. Checked exceptions can't be propagated with throw only, but throws allow doing so without the need for anything else. The throws keyword is followed by a class, whereas the throw keyword is followed by an instance. The throw keyword is used within the method, but the throws keyword is used with the method signature. Furthermore, it is not possible to throw multiple exceptions, but it is possible to declare multiple exceptions."
    },
    {
        "question": "Explain various exceptions handling keywords in Java?",
        "answer": "Answer:\nThere is two crucial exception handling keywords in Java, followed by the third keyword final, which may or may not be used after handling exceptions.\ntry:\nIf and when a code segment has chances of having and abnormality or an error, it is placed within a try block. When the exception is raised, it is handled and caught by the catch block.\nTry block must have a catch() or a final() or both blocks after it.\ncatch:\nWhen an exception is raised in the try block, it is handled in the catch block.\nfinal:\nThis block is executed regardless of the exception. It can be placed either after try{} or catch {} block."
    },
    {
        "question": "Explain exception propagation?",
        "answer": "The method at the top of the stack throws an exception if it is not caught. It moves to the next method and goes on like this until caught.\nExample:\npublic class Sum()\n{\npublic static void main(String args[])\n{\naddition()\n}\npublic void addition()\n{\nadd();\n}\n}\nThe stack of the above code is:\nadd()\naddition()\nmain()\nIf an exception occurred in the add() method is not caught, then it moves to the method addition(). It is then moved to the main() method, where the flow of execution stops. It is called Exception Propagation.\nFile Handling Java Interview Questions"
    },
    {
        "question": "Does an empty file name with .java extension a valid file name?",
        "answer": "Yes, Java permits to save our java file by .java only. It is compiled by javac .java and run by java class name.\nLet's take a simple example:\npublic class Any()\n{\npublic static void main(String args[])\n{\nSystem.out.println(\"Hello Java File here!\");\n}\n}\nTo compile: javac.java\nTo run: Java Any\nCollections Java Interview Questions"
    },
    {
        "question": "What do you mean by Collections in Java? What are the constituents of Collections in Java?",
        "answer": "A group of objects in Java is known as collections. Java.util package contains, along with date and time facilities, internationalization, legacy collection classes, etc., the various classes and interfaces for collecting. Alternatively, collections can be considered as a framework designed for storing the objects and manipulating the design in which the objects are stored. You can use collections to perform the following operations on objects:\nDeletion\nInsertion\nManipulation\nSearching\nSorting\nFollowing are the various constituents of the collections framework:\nClasses – Array List, Linked List, Lists, and Vector\nInterfaces – Collection, List, Map, Queue, Set, Sorted Map, and Sorted Set\nMaps – HashMap, HashTable, LinkedHashMap, and TreeMap\nQueues – Priority Queue\nSets – Hash Set, Linked Hash Set, and Tree Set"
    },
    {
        "question": "How will you differentiate HashMap from HashTable?",
        "answer": "HashMap in Java is a Map-based collection class, used for storing key & value pairs. It is denoted as HashMap<Key, Value> or HashMap<K, V> HashTable is an array of a list, where each list is called a bucket. Values contained in a HashTable are unique and depend on the key. Methods are not synchronized in HashMap, while key methods are synchronized in HashTable. However, HashMap doesn't have thread safety, while HashTable has the same. For iterating values, HashMap uses iterator and HashTable uses enumerator. HashTable doesn't allow anything that is null, while HashMap allows one null key and several null values. In terms of performance, HashTable is slow. Comparatively, HashMap is faster."
    },
    {
        "question": "Please explain Map and their types in Java.",
        "answer": "A Java Map is an object that maps keys to values. It can't contain duplicate keys, and each key can map to only one value. In order to determine whether two keys are the same or distinct, Map makes use of the equals() method. There are 4 types of Map in Java, described as follows:\nHashMap - It is an unordered and unsorted map and hence, is a good choice when there is no emphasis on the order. A HashMap allows one null key and multiple null values and doesn't maintain any insertion order.\nHashTable – Doesn't allow anything null and has methods that are synchronized. As it allows for thread safety, the performance is slow.\nLinkedHashMap – Slower than a HashMap but maintains insertion order and has a faster iteration.\nTreeMap – A sorted Map providing support for constructing a sort order using a constructor."
    },
    {
        "question": "What do you mean by Priority Queue in Java?",
        "answer": "Priority queue, like a regular queue, is an abstract data type except having a priority associated with each element contained by it. The element with the high priority is served before the element with low priority in a priority queue. Elements in a priority queue are ordered either according to the comparator or naturally. The order of the elements in a priority queue represents their relative priority."
    },
    {
        "question": "What is Set in Java? Also, explain its types in a Java Collections.",
        "answer": "In Java, a Set is a collection of unique objects. It uses the equals() method to determine whether two objects are the same or not. Various types of Set in Java Collections are:\nHash Set– An unordered and unsorted set that uses the hash code of the object for adding values. Used when the order of the collection isn't important\nLinked Hash Set– This is an ordered version of the hash set that maintains a doubly-linked list of all the elements. Used when iteration order is mandatory. Insertion order is the same as that of how elements are added to the Set.\nTree Set– One of the two sorted collections in Java, it uses Read-Black tree structure and ensures that the elements are present in the ascending order."
    },
    {
        "question": "What is ordered and sorted concerning collections?",
        "answer": "Answer:\nOrdered\nIt means that values are stored in a collection in a specific order, but the order is independent of the value. Eg. List\nSorted\nIt means the collection has an order which is dependent on the value of an element.\nEg. SortedSet\nMiscellaneous Java Interview Questions "
    },
    {
        "question": "Please explain the various types of garbage collectors in Java?",
        "answer": "The Java programming language has four types of garbage collectors:\nSerial Garbage Collector– Using only a single thread for garbage collection, the serial garbage collector works by holding all the application threads. It is designed especially for single-threaded environments. Because serial garbage collector freezes all application threads while performing garbage collection, it is most suitable for command-line programs only. For using the serial garbage collector, one needs to turn on the -XX:+UseSerialGC JVM argument.\nParallel Garbage Collector – Also known as the throughput collector, the parallel garbage collector is the default garbage collector of the JVM. It uses multiple threads for garbage collection, and like a serial garbage collector freezes all application threads during garbage collection.\nCMS Garbage Collector– Short for Concurrent Mark Sweep, CMS garbage collector uses multiple threads for scanning the heap memory for marking instances for eviction, followed by sweeping the marked instances. There are only two scenarios when the CMS garbage collector holds all the application threads:\nWhen marking the referenced objects in the tenured generation space\nIf there is some change in the heap memory while performing the garbage collection, CMS garbage collector ensures better application throughput over parallel garbage collectors by using more CPU. For using the CMS garbage collector, the XX:+USeParNewGC JVM argument needs to be turned on.\nG1 Garbage Collector – Used for large heap memory areas, G1 garbage collector works by separating the heap memory into multiple regions and then executing garbage collection in them in parallel. Unlike the CMS garbage collector that compacts the memory on STW (Stop The World) situations, G1 garbage collector compacts the free heap space right after reclaiming the memory. Also, the G1 garbage collector prioritizes the region with the most garbage. Turning on the –XX:+UseG1GC JVM argument is required for using the G1 garbage collector."
    },
    {
        "question": "What do you understand by Synchronization in Java? What is its most significant disadvantage?",
        "answer": "If several threads try to access a single block of code, then there is an increased chance of producing inaccurate results. Synchronization is used to prevent this. Using the synchronization keyword makes a thread need a key to access the synchronized code. Simply, synchronization allows only one thread to access a block of code at a time. Each Java object has a lock, and every lock has only one key. A thread can access a synchronized method only if it can get the key to the lock of the object. Following example demonstrates synchronization:\npublic class ExampleThread implements Runnable {\npublic static void main (String[] args){\nThread t = new Thread();\nt.start();\n}\npublic void run(){\nsynchronized(object){\n{\n}\n}\nNote: It is recommended to avoid implementing synchronization for all methods. This is because when only one thread can access the synchronized code, the next thread needs to wait. Consequently, it results in slower performance of the program."
    },
    {
        "question": "Can you tell the difference between execute(), executeQuery(), and executeUpdate()?",
        "answer": "Answer:\nexecute() – Used for executing an SQL query. It returns TRUE if the result is a ResultSet, like running Select queries, and FALSE if the result is not a ResultSet, such as running an Insert or an Update query.\nexecuteQuery() – Used for executing Select queries. It returns the ResultSet, which is not null, even if no records are matching the query. The executeQuery() method must be used when executing select queries so that it throws the java.sql.SQLException with the 'executeQuery method cannot be used for update' message when someone tries to execute an Insert or Update statement.\nexecuteUpdate() – Used for executing Delete/Insert/Update statement or DDL statements that returns nothing. The output varies depending on whether the statements are Data Manipulation Language (DML) statements or Data Definition Language (DDL) statements. The output is an integer and equals the total row count for the former case, and 0 for the latter case.\nNote: The execute() method needs to be used only in a scenario when there is no certainty about the type of statement. In all other cases, either use executeQuery() or executeUpdate() method."
    },
    {
        "question": "Provide an example of Hibernate architecture:",
        "answer": "Answer:"
    },
    {
        "question": "Could you demonstrate how to delete a cookie in JSP with a code example?",
        "answer": "Following code demonstrates deleting a cookie in JSP:\nCookie mycook = new Cookie(\"name1\",\"value1\");\nresponse.addCookie(mycook1);\nCookie killmycook = new Cookie(\"mycook1\",\"value1\");\nkillmycook . set MaxAge ( 0 );\nkillmycook . set Path (\"/\");\nkillmycook . addCookie ( killmycook 1 );"
    },
    {
        "question": "Write suitable code examples to demonstrate the use of final, final, and finalize.",
        "answer": "Final:  The final keyword is used for restricting a class, method, and variable. A final class can't be inherited, a final method is disabled from overriding, and a final variable becomes a constant i.e., its value can't be changed.\nclass FinalVarExample {\npublic static void main( String args[])\n{\nfinal int a=10;\na=50; /* Will result in an error as the value can’t be changed now*/\n}\nFinally: Any code inside the final block will be executed, irrespective of whether an exception is handled or not.\nclass FinallyExample {\npublic static void main(String args[]){\ntry {\nint x=100;\n}\ncatch(Exception e) {\nSystem.out.println(e);\n}\nfinally {\nSystem.out.println(\"finally block is executing\");}\n}\n}\n}\nFinalize: The finalize method performs the clean up just before the object is garbage collected.\nclass FinalizeExample {\npublic void finalize() {\nSystem.out.println(\"Finalize is called\");\n}\npublic static void main(String args[])\n{\nFinalizeExample f1=new FinalizeExample();\nFinalizeExample f2=new FinalizeExample();\nf1= NULL;\nf2=NULL;\nSystem.gc();\n}\n}"
    },
    {
        "question": "What purpose do the Volatile variable serve in Java?",
        "answer": "The value stored in a volatile variable is not read from the thread's cache memory but from the main memory. Volatile variables are primarily used during synchronization."
    },
    {
        "question": "Please compare Serialization with Deserialization in Java.",
        "answer": "Serialization is the process by which Java objects are converted into the byte stream. Deserialization is the exact opposite process of serialization where Java objects are retrieved from the byte stream. A Java object is serialized by writing it to an ObjectOutputStream and deserialized by reading it from an ObjectInputStream."
    },
    {
        "question": "What do you understand by OutOfMemoryError in Java?",
        "answer": "Typically, the OutOfMemoryError exception is thrown when the JVM is not able to allocate an object due to running out of memory. In such a situation, no memory could be reclaimed by the garbage collector. There can be several reasons that result in the OutOfMemoryError exception, out of which most notable ones are:\nHolding objects for too long\nTrying to process too much data at the same time\nUsing a third-party library that caches strings\nUsing an application server that doesn't perform a memory cleanup post the deployment\nWhen a native allocation can't be satisfied\nThat completes the list of top Java interview questions. What do you think about the list we compiled? Let us know by dropping your comments in the dedicated window below. Also, check out these best Java tutorials to further refine your Java skill set."
    },
    {
        "question": "Explain public static void main(String args[ ]) in Java",
        "answer": "The execution Java program starts with public static void main(String args[ ]), also called the main() method.\npublic: It is an access modifier defining the accessibility of the class or method. Any Class can access the main() method defined public in the program.\nstatic: The keyword indicates the variable, or the method is a class method. The method main() is made static so that it can be accessed without creating the instance of the class. When the method main() is not made static, the compiler throws an error because the main() is called by the JVM before any objects are made, and only static methods can be directly invoked via the class.\nvoid: It is the return type of the method. Void defines the method does not return any type of value.\nmain: JVM searches this method when starting the execution of any program, with the particular signature only.\nString args[]: The parameter passed to the main method."
    },
    {
        "question": "What are wrapper classes in Java?",
        "answer": "Wrapper classes are responsible for converting the Java primitives into the reference types (objects). A class is dedicated to every primitive data type. They are known as wrapper classes because they wrap the primitive data type into an object of that class. It is present in Java.lang package. The table below displays the different primitive types, wrapper class.\nSimple Type\tWrapper Class\nboolean\tBoolean\nchar\tCharacter\ndouble\tDouble\nfloat\tFloat\nint\tInteger\nlong\tLong"
    },
    {
        "question": "Explain the concept of boxing, unboxing, autoboxing, and auto unboxing.",
        "answer": "Answer:\nBoxing: The concept of putting a primitive value inside an object is called boxing.\nUnboxing: Getting the primitive value from the object.\nAutoboxing: Assigning a value directly to an integer object.\nAuto unboxing: Getting the primitive value directly into the integer object.\npublic class BoxUnbox\n{\npublic static void main(String args[])\n{\nint i = 5;\nInteger ii = new Integer(i);            /*Boxing*/\nInteger jj = i; /*Unboxing*/\nint j = jj.intValue();      /*Unboxing*/\nint k = jj; /*AutoUnboxing*/\n}\n}"
    },
    {
        "question": "Define the Singleton class in Java. How can a class be made Singleton?",
        "answer": "A Singleton class allows only one instance of the class to be created.\nA class can be made singleton with the following steps:\nCreating a static instance of the class with the class.\nBy not allowing the user to create an instance with default constructor by defining private constructor.\nCreate a static method to return the object of an instance of A.\npublic class Singleton\n{\npublic static void main(String args[])\n{\nSingle obj1 = Single.getInstance();  /* both would point to one and same instance of the class */\nSingle obj2 = Single.getInstance();\n}\n}\nclass Single\n{\nstatic Single obj = new Single(); /* step a*/\nprivate Single() /* step b*/\n{\n}\npublic static Single getInstance()\n{\nreturn obj; /* step c*/\n}\n}"
    },
    {
        "question": "What if the public static void is replaced by static public void, will the program still run?",
        "answer": "Yes, the program would compile and run without any errors as the order of the specifiers don't matter."
    },
    {
        "question": "Differentiate between == and equals() ?",
        "answer": "Answer:\nEquals()\t==\nIt is a method of String class\tIt is an operator.\nContent comparison\tAddress comparison\n\nclass Operator {\npublic static void main(String[] args)\n{\n/* integer-type*/\nSystem.out.println(10 == 20);\n/* char-type*/\nSystem.out.println('a' == 'b');\n/* char and double type*/\nSystem.out.println('a' == 97.0);\n/* boolean type*/\nSystem.out.println(true == true);\n}\n}\n\t\npublic class Equals{\npublic static void main(String[] args)\n{\nString s1 = new String(\"HELLO\");\nString s2 = new String(\"HELLO\");\nSystem.out.println(s1 == s2);\nSystem.out.println(s1.equals(s2));\n}\n}"
    },
    {
        "question": "Why don't we use pointers in Java?",
        "answer": "Pointers are considered to be unsafe, and increase the complexity of the program, add\ning the concept of pointers can be contradicting. Also, JVM is responsible for implicit memory allocation; thus, to avoid direct access to memory by the user, pointers are discouraged in Java."
    },
    {
        "question": "Questions: Differentiate between this() and super()",
        "answer": ""
    },
    {
        "question": "Answer:",
        "answer": "this()\tsuper()\nRepresents the current instance of the class.\tRepresents the current instance of the parent/base class.\nIt is used to call the default constructor of the same class\tIt is used to call the default constructor of the parent/base class.\nAccesses method of the current class\tAccesses method of the base class\nPoints current class instance\tPoints to the superclass instance.\nMust be the first line of the block\tIt must be the first line of the block.\nJava Coding Interview Questions \nApart from having good knowledge about concepts of Java programming, you are also tested for your skills in coding in Java programming language. Given below are Java Coding Interview Questions that are relevant for freshers and are quite popular amongst Java programming interviews."
    },
    {
        "question": "Take a look at the two code snippets below:",
        "answer": "i.\nclass Adder {\nStatic int add(int a, int b)\n{\nreturn a+b;\n}\nStatic double add( double a, double b)\n{\nreturn a+b;\n}\npublic static void main(String args[])\n{\nSystem.out.println(Adder.add(11,11));\nSystem.out.println(Adder.add(12.3,12.6));\n}}\nii.\nclass Car {\nvoid run(){\nSystem.out.println(“car is running”);\n}\nClass Audi extends Car{\nvoid run()\n{\nSystem.out.prinltn(“Audi is running safely with 100km”);\n}\npublic static void main( String args[])\n{\nCar b=new Audi();\nb.run();\n}\n}"
    },
    {
        "question": "What is the important difference between the two?",
        "answer": "Code snippet i. is an example of method overloading while the code snippet ii. demonstrates method overriding."
    },
    {
        "question": "Questions: Program for string reversal without using inbuilt function",
        "answer": "Answer:\npublic class Reversal\n{\npublic static void main(String args[])\n{\nString input = \"Java Interview\";\nSystem.out.println(\"Given String -> \" + \"Java Interview\");\nchar charArray[] = input.toCharArray();\nSystem.out.println(\"Reversed String -> \");\nfor(int i = charArray.length-1;i>=0; i--)\n{\nSystem.out.print(charArray[i]);\n}\nSystem.out.println();\n}\n}"
    },
    {
        "question": "Questions: Program to delete duplicate from an array",
        "answer": "Answer:\nimport java.util.ArrayList;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nclass RemoveDuplicates\n{\npublic static void main(String args[])\n{\n/*create ArrayList with duplicate elements*/\nArrayList duplicate = new ArrayList();\nduplicate.add(5);\nduplicate.add(7);\nduplicate.add(1);\nduplicate.add(4);\nduplicate.add(1);\nduplicate.add(7);\nSystem.out.println(\"Given array: \"+ duplicate);\nSet <Integer> withoutDuplicates = new LinkedHashSet<Integer>(duplicate)\nduplicate.clear();\nduplicate.addAll(withoutDuplicates);\nSystem.out.println(\"Array without duplicates: \"+ duplicate);\n}\n}"
    },
    {
        "question": "Questions: Program to reverse a number",
        "answer": "Answer:\nimport java.util.Scanner;\npublic class NumberReversal\n{\npublic static void main(String args[])\n{\nSystem.out.println(\"Please enter the number to be reversed\");\nScanner sc = new Scanner (System.in);\nint number = sc.nextInt();\nint reverse = reverse(number);\nSystem.out.println(\"Reverse of number: \" + number + \" is \" + reverse(number));\n}\npublic static int reverse(int number){\nint reverse = 0;\nint remainder = 0;\ndo{\nremainder = number%10;\nreverse = reverse*10 + remainder;\nnumber = number/10;\n}while(number > 0);\n   return reverse;\n}\n}"
    },
    {
        "question": "Questions: Program for binary search",
        "answer": "Answer:\nimport java.util.Scanner;\nimport java.util.Arrays;\npublic class Binary {\npublic static void main(String[] args) {\nSystem.out.println(\"Enter total number of elements : \");\nScanner s = new Scanner (System.in);\nint length = s.nextInt();\nint[] input = new int[length];\nSystem.out.printf(\"Enter %d integers\", length);\nfor (int i = 0; i < length; i++) {\ninput[i] = s.nextInt();\n}\n/* binary search requires the input array to be sorted so we must sort the array first*/\nArrays.sort(input);\nSystem.out.print(\"the sorted array is: \");\nfor(int i= 0; i<= length-1;i++)\n{\nSystem.out.println(input[i] + \" ,\");\n}\nSystem.out.println(\"Please enter number to be searched in sorted array\");\nint key = s.nextInt();\nint index = BSearch(input, key);\nif (index == -1) {\nSystem.out.printf(\"Sorry, %d is not found in array %n\", key);\n} else {\nSystem.out.printf(\"%d is found in array at index %d %n\", key,\nindex);\n}\n}\npublic static int BSearch(int[] input, int number) {\nint low = 0;\nint high = input.length - 1;\nwhile (high >= low) {\nint middle = (low + high) / 2;\nif (input[middle] == number) {\nreturn middle;\n} else if (input[middle] < number) {\nlow = middle + 1;\n} else if (input[middle] > number) {\nhigh = middle - 1;\n}\n}\nreturn -1;\n}\n}"
    },
    {
        "question": "Questions: Program to check if a number is prime.",
        "answer": "Answer:\nimport java.util.Scanner;\npublic class Prime\n{\npublic static void main(String args[])\n{\nSystem.out.println(\"Enter the number to check: \");\nScanner sc = new Scanner(System.in);\nint num = sc.nextInt();\nboolean isPrime = false;\n  if(num!=0)\n  {\n  isPrime = checkPrime(num);\n  }else\n  {\n  System.out.println(\"Enter valid number\");\n  }\n  if(isPrime == false)\n  {\n  System.out.println(\" NOT PRIME!!\");\n  }\n  else\n  {\n  System.out.println(\"PRIME!!\");\n  }\n}\npublic static boolean checkPrime(int number)\n{\nint sqrt = (int) Math.sqrt(number) + 1;\nfor(int i = 2; i<sqrt; i++)\n{\nif(number % i== 0)\n{\nreturn false;\n}\n}\nreturn true;\n}\n}"
    },
    {
        "question": "Questions: Program to print Fibonacci Series",
        "answer": "Answer:\nimport java.util.Scanner;\npublic class Fibo\n{\npublic static void main(String args[])\n{\nSystem.out.println(\"Enter the number upto which Fibonacci series should be printed \");\nScanner sc = new Scanner(System.in);\nint num = sc.nextInt();\nSystem.out.println(\"Fibonacci Series upto %d is\" + num);\nfor(int i=1; i<=num; i++)\n{\nSystem.out.print(fib(i) + \" \");\n}\n}\npublic static int fib(int n)\n{\nif(n ==1 || n==2)\n{\nreturn 1;\n}\nreturn fib(n-1) + fib(n-2);\n}\n}"
    },
    {
        "question": "Questions: Program to check if the given string is a palindrome.",
        "answer": "Answer:\nimport java.util.Scanner;\npublic class PalinDrome\n{\npublic static void main(String args[])\n{\nSystem.out.println(\"Enter the string to check\");\nScanner sc = new Scanner(System.in);\nString str = sc.nextLine();\nboolean isPalindrome;\nisPalindrome = checkPalindrome(str);\nif(str.equals(\" \"))\n{\nSystem.out.println(\"Enter valid string\");\n}\nelse\n{\nif(isPalindrome)\n{\nSystem.out.println(\"PALINDROME!!\");\n}\nelse\n{\nSystem.out.println(\"NOT A PALINDROME!!\");\n}\n}\n}\npublic static boolean checkPalindrome(String input)\n{\nint str_length = input.length();\nint i=0, j= str_length-1;\nwhile(i<j)\n{\nif(input.charAt(i) != input.charAt(j))\nreturn false;\ni++;\nj--;\n}\nreturn true;\n}\n}\nQuestions: Pattern printing\n*\n* *\n* * *\n* * * *\n* * * * *\nAnswer:\npublic class Pattern\n{\npublic static void main(String args[])\n{\n for(int i=5; i>=0; i--)\n {\n System.out.println();\n for(int j=i; j<5;j++)\n {\n System.out.print(\" * \");\n }\n }\n System.out.println();\n}\n}"
    },
    {
        "question": "Questions: Program to swap two numbers",
        "answer": "Answer:\nimport java.util.Scanner;\npublic class Swap\n{\npublic static void main(String args[])\n{\nScanner s = new Scanner(System.in);\nSystem.out.println(\"Enter a number: \");\nint a = s.nextInt();\nSystem.out.println(\"Enter second number: \");\nint b = s.nextInt();\nSystem.out.println(\"Value of a and b before swapping: \" + \"a = \" +a  + \" b = \" + b);\nswap(a,b);\n}\npublic static void swap(int a , int b)\n{\nint swap_variable;\nswap_variable = a;\na = b;\nb = swap_variable;\nSystem.out.println(\"Value of a and b after swapping: \" + \"a = \" +a  + \" b = \" + b);\n}\n}"
    },
    {
        "question": "Questions: Program to check if the given number is an Armstrong number.",
        "answer": "Answer:\nimport java.util.Scanner;\npublic class Armstrong\n{\npublic static void main(String args[])\n{\nScanner s = new Scanner(System.in);\nSystem.out.println(\"Enter a number: \");\nint number = s.nextInt();\nint a=number, sum = 0, num=0;\n  while(a%10 !=0)\n  {\n  num = a%10;\n  sum = sum + (num*num*num);\na = a/10;\n  }\n  if(sum == number)\n  {\n  System.out.println(\"Armstrong Number!\");\n  }\n  else\n  {\n  System.out.println(\"Not an Armstrong Number!\");\n  }\n}\n}\nWe have also provided a PDF for your preparation so that you can download and learn and prepare on the go. Download Java Interview Questions PDF\nSummary\nThe aforementioned Core Java Interview Questions and Java Programming Interview Questions is the creme collection to prepare you for the interview as every concept is explained in much detail. Inside reference, links are also provided for your further reading. \nJava is a broad field of study. Buy this course for further reading and preparing for a Java-based interview: Java interview Guides: 200+ Interview Question and Answer\nFollow this book that will help you crack core Java interviews: Elements of Programming Interviews in Java: The insider guide second edition\nWe also suggest you share your interview experiences and Java programming interview quotations that you come across in your different tech company interviews. Share with us in the comments below so that we can all help each other and build an interactive community to learn and crack the Java interview for our dream job.\nPeople are also reading:\nBest Java Courses\nTop 10 Java Certifications\nBest Java Books\nBest Java Projects\nTop Java Programming Interview Questions\nCore Java Cheatsheet - Introduction to Programming in Java\nDifference between Java vs Javascript\nTop 10 Java Frameworks\nBest Way to Learn Java\nConstructor in java \nPrime Number Program in Java\n"
    }
]